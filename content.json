{"meta":{"title":"ChaosCoffee' blog","subtitle":null,"description":null,"author":"ChaoCofee","url":"https://chaoscoffee.github.io"},"pages":[{"title":"categories","date":"2018-07-27T06:39:54.000Z","updated":"2018-08-21T02:11:05.940Z","comments":true,"path":"categories/index.html","permalink":"https://chaoscoffee.github.io/categories/index.html","excerpt":"","text":""},{"title":"interview","date":"2018-07-27T06:39:54.000Z","updated":"2018-08-21T02:11:05.940Z","comments":true,"path":"categories/interview/index.html","permalink":"https://chaoscoffee.github.io/categories/interview/index.html","excerpt":"","text":""},{"title":"programmes","date":"2018-07-27T06:39:54.000Z","updated":"2018-08-21T02:11:05.940Z","comments":true,"path":"categories/programmes/index.html","permalink":"https://chaoscoffee.github.io/categories/programmes/index.html","excerpt":"","text":""},{"title":"tools","date":"2018-07-27T06:39:54.000Z","updated":"2018-08-21T02:11:05.940Z","comments":true,"path":"categories/tools/index.html","permalink":"https://chaoscoffee.github.io/categories/tools/index.html","excerpt":"","text":""}],"posts":[{"title":"Maven-deploy配置方法","slug":"Maven-deploy配置方法","date":"2018-08-20T08:49:39.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/20/Maven-deploy配置方法/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/20/Maven-deploy配置方法/","excerpt":"","text":"Maven-deploy配置方法 Maven-deploy配置方法 deploy解释 setting.xml配置 pom.xml配置 deploy解释deploy顾名思义，就是上传的意思。在本地的pom文件配置好之后，执行deploy命令，可以将maven所打的jar包上传到远程的repository，便于其他开发者和工程共享 setting.xml配置12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;Snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; pom.xml配置123456789101112&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;Internal Releases&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;Snapshots&lt;/id&gt; &lt;name&gt;Internal Releases&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 说明: id和url务必写正确，否则无法正确deploy，这个步骤需要验证用户信息，所以与上一步骤server id对应上","categories":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://chaoscoffee.github.io/tags/Maven/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}]},{"title":"GitLab持续集成/部署-Runner核心介绍","slug":"GitLab持续集成-部署-Runner核心介绍","date":"2018-08-17T08:01:03.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/17/GitLab持续集成-部署-Runner核心介绍/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/17/GitLab持续集成-部署-Runner核心介绍/","excerpt":"","text":"GitLab持续集成/部署-Runner核心介绍 GitLab持续集成/部署-Runner核心介绍 GitLab-Runner简介 GitLab-Runner架构图 构成组件 Pipeline Stages Jobs 扩展 Shared Runners如何挑选Jobs Example 1 Example 2 参考 GitLab-Runner简介GitLab提供了自动集成、测试，部署的服务，这个动作由GitLab Runner来实现。 GitLab CI 脚本的执行者 GitLab-Runner架构图 构成组件Pipeline 官方解释: pipeline是一组分阶段执行的作业（批处理）。一个阶段中的所有作业都是并行执行的（如果有足够的并发Runners），如果它们都成功，那么pipeline就会进入下一个阶段。如果其中一个作业失败，则不会（通常）执行下一个阶段 一般来说，Pipeline 表示构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程,任何提交或者 Merge Request 的合并都可以触发 Pipeline StagesStages 表示构建阶段，一次 Pipeline 中定义多个 Stages。 所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始 只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败 JobsJobs 表示构建工作，表示某个 Stage 里面执行的工作。一个 Stages 里面定义多个 Jobs， Jobs 会有以下特点：相同 Stage 中的 Jobs 会并行执行相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败 扩展Shared Runners如何挑选Jobs Shared Runners遵守我们称之为合理使用的进程队列。公平使用算法尝试从当前在共享Runners上运行的作业数量最少的项目中将作业分配给共享的Runners。 Example 1We have following jobs in queue: Job 1 for Project 1 Job 2 for Project 1 Job 3 for Project 1 Job 4 for Project 2 Job 5 for Project 2 Job 6 for Project 3 jobs会按照以下顺序分配: 首先选择Job 1，因为它没有正在运行的作业（即所有项目）的作业编号最低 接下来是Job 4，因为4现在是没有正在运行的作业的项目中的最低Job 编号（项目1正在运行作业） 接下来是Job 6，因为6现在是没有正在运行的Job 的项目中的最低Job 编号（项目1和2有作业正在运行） 接下来是Job 2，因为在运行的Job 数量最少的项目中（每个都有1个），它是最低的Job 编号 接下来是Job 5，因为项目1现在有2个Job 正在运行，而在项目2和3之间，Job 5是剩余的最低Job 编号 最后，我们选择了Job 3 …因为这是唯一剩下的工作 Example 2We have following jobs in queue: Job 1 for Project 1 Job 2 for Project 1 Job 3 for Project 1 Job 4 for Project 2 Job 5 for Project 2 Job 6 for Project 3 jobs会按照以下顺序分配: 首先选择Job 1，因为它没有正在运行的作业（即所有项目）的作业编号最低 我们完成了工作1 接下来是Job 2，因为在完成Job 1后，所有项目都有0个作业再次运行，2是最低可用作业号 接下来是Job 4，因为项目1运行作业时，4是没有作业的项目中的最小数字（Project 2和3） 我们完成了工作4 接下来是Job 5，因为完成了Job 4，Job 2没有再次运行作业 接下来是Job 6，因为Project 3是唯一没有正在运行的作业的项目 最后，我们选择了Job 3 …因为，这是唯一剩下的工作（who says 1 is the loneliest number?） 参考Gitlab-CI/CD 持续集成Introduction to pipelines and jobs Configuring GitLab Runners","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://chaoscoffee.github.io/categories/DevOps/"}],"tags":[{"name":"GitLab-CI","slug":"GitLab-CI","permalink":"https://chaoscoffee.github.io/tags/GitLab-CI/"}],"keywords":[{"name":"DevOps","slug":"DevOps","permalink":"https://chaoscoffee.github.io/categories/DevOps/"}]},{"title":"利用Chrome原生工具进行网页长截图","slug":"利用Chrome原生工具进行网页长截图","date":"2018-08-15T03:10:57.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/15/利用Chrome原生工具进行网页长截图/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/15/利用Chrome原生工具进行网页长截图/","excerpt":"","text":"Chrome原生工具进行网页长截图 Chrome原生工具进行网页长截图 准备工作 打开调试界面 网页截图 普通网页长截图 1. 打开网页截图工具 2. 输入截图命令 3. 截图 手机版网页长截图 1. 模拟手机设备 2. 手机截图 3. 输入命令 区域截图 1. 区域选中 2. 截图命令 扩展 准备工作在想要截图的网页中，按着以下快捷键 打开调试界面 MacOs ⌘Command + ⌥Option + IWindows 为 F12 网页截图普通网页长截图 1. 打开网页截图工具 MacOs ⌘Command + ⇧Shift + PWindow Ctrl + Shift + P 2. 输入截图命令输入前几个字母就会匹配到,输入以下命令Capture full size screenshot 3. 截图选中所在的命令,敲下回车 Enter 手机版网页长截图1. 模拟手机设备 MacOs ⌘Command + ⇧Shift + MWindows Ctrl + Shift + M 注意: 后面再使用普通的网页截图，仍然使用以上的命令进行切换 2. 手机截图在顶部的工具栏中，你可以选择要模拟的设备和分辨率等设置。 3. 输入命令与 普通网页网页长截图 中1. 2. 3.步骤相同 区域截图 1. 区域选中 MacOs ⌘Command + ⇧Shift + CWindows Ctrl + Shift + C 按照上面命令然后鼠标悬浮在上面,出现蓝色选中区域为止 2. 截图命令先打开截图工具(参见: 普通网页长截图 步骤1),再按着命令 Capture node screenshot 实现区域截图 扩展Capture full size screenshot 命令实现完成网页截图Capture node screenshot 命令实现区域截图Capture screenshot 命令可以截取当前网页的可视部分","categories":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}],"tags":[],"keywords":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}]},{"title":"Ingress-实践","slug":"Ingress-实践","date":"2018-08-10T09:43:08.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/10/Ingress-实践/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/10/Ingress-实践/","excerpt":"","text":"Ingress 实践 Ingress 实践 Kubernetes 暴露服务方式 LoadBlancer Service NodePort Service Ingress Ingress 介绍 Ingress 部署 default-backend Ingress Controller 快速部署 创建相关资源 创建ingress-nginx服务 测试 配置TLS SSL访问 创建证书 创建 Secret 快速创建 Secret 重新部署 参考文档 Kubernetes 暴露服务方式到目前为止 Kubernetes 暴露服务的有三种方式，分别为 LoadBlancer Service NodePort Service Ingress LoadBlancer ServiceLoadBlancer Service 是 Kubernetes 结合云平台的组件，如国外 GCE、AWS、国内阿里云等等，使用它向使用的底层云平台申请创建负载均衡器来实现，有局限性，对于使用云平台的集群比较方便。 NodePort ServiceNodePort Service 是通过在节点上暴漏端口，然后通过将端口映射到具体某个服务上来实现服务暴漏，比较直观方便，但是对于集群来说，随着 Service 的不断增加，需要的端口越来越多，很容易出现端口冲突，而且不容易管理。当然对于小规模的集群服务，还是比较不错的。 IngressIngress解决的是新的服务加入后，域名和服务的对应问题，基本上是一个ingress的对象，通过yaml进行创建和更新进行加载。 Ingress使用开源的反向代理负载均衡器来实现对外暴漏服务，比如 Nginx、Apache、Haproxy等。Nginx Ingress 一般有三个组件组成： Nginx 反向代理负载均衡器 Ingress ControllerIngress Controller可以理解为控制器，它通过不断的跟 Kubernetes API 交互，实时获取后端 Service、Pod 等的变化，比如新增、删除等，然后结合 Ingress 定义的规则生成配置，然后动态更新上边的 Nginx 负载均衡器，并刷新使配置生效，来达到服务自动发现的作用，简单来说，Ingress这种变化生成一段Nginx的配置，然后将这个配置通过Kubernetes API写到Nginx的Pod中，然后reload IngressIngress 则是定义规则，通过它定义某个域名的请求过来之后转发到集群中指定的 Service。它可以通过 Yaml 文件定义，可以给一个或多个 Service 定义一个或多个 Ingress 规则。 Ingress 介绍 官网对 Ingress 的定义为管理对外服务到集群内服务之间规则的集合，通俗点讲就是它定义规则来允许进入集群的请求被转发到集群中对应服务上，从来实现服务暴漏。 Ingress 能把集群内 Service 配置成外网能够访问的 URL，流量负载均衡，终止SSL，提供基于域名访问的虚拟主机等等。 Ingress解决的是新的服务加入后，域名和服务的对应问题，基本上是一个ingress的对象，通过yaml进行创建和更新进行加载。可以通过ConfigMap提供的Nginx命令修改参数。 Ingress 部署default-backenddefault-backend生成一个默认的后端，如果遇到解析不到的URL或者发生错误就转发到默认后端dashboard.yaml123456789101112131415161718apiVersion: extensions/v1beta1kind: Ingressmetadata: name: dashboard-weblogic-ingress namespace: kube-systemspec: rules: - host: helloworld.eric http: paths: - path: /console backend: serviceName: helloworldsvc servicePort: 7001 - path: / backend: serviceName: kubernetes-dashboard servicePort: 80 host 指虚拟出来的域名，具体地址(Ingress-controller那台Pod所在的主机的地址)应该加入/etc/hosts中,这样所有去helloworld.eric的请求都会发到nginx path:/console 匹配后面的应用路径 servicePort 主要是定义服务的时候的端口，不是NodePort. path:/ 匹配后面dashboard应用的路径,以前通过访问master节点8080/ui进入dashboard的，但dashboard其实是部署在minion节点中，实际是通过某个路由语句转发过去而已，dashboard真实路径如下: Ingress Controller $ kubectl create -f ingress-nginx/examples/deployment/nginx/nginx-ingress-controller.yaml 快速部署创建相关资源 $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/mandatory.yaml 创建ingress-nginx服务 $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/provider/baremetal/service-nodeport.yaml 测试 $ kubectl get svc -o wide -n ingress-nginx$ kubectl create -f hello-world-deployment.yaml 123456789101112131415161718192021222324252627282930apiVersion: apps/v1beta1kind: Deploymentmetadata: name: hello-world-deploymentspec: replicas: 1template: metadata: labels: app: hello-world spec: containers: - image: &quot;gokul93/hello-world:latest&quot; imagePullPolicy: Always name: hello-world-container ports: - containerPort: 8080---apiVersion: v1kind: Servicemetadata: name: hello-world-svcspec: ports: - port: 8080 protocol: TCP targetPort: 8080selector: app: hello-worldtype: NodePort $ kubectl create -f hello-world-ingress.yaml1234567891011121314151617181920apiVersion: extensions/v1beta1kind: Ingressmetadata:annotations: nginx.ingress.kubernetes.io/ssl-redirect: &quot;false&quot;creationTimestamp: 2018-08-03T02:51:13Zgeneration: 2name: hello-world-ingressnamespace: defaultresourceVersion: &quot;3668608&quot;selfLink: /apis/extensions/v1beta1/namespaces/default/ingresses/hello-world-ingressuid: 15b9c53b-96c8-11e8-9920-00505683568fspec:rules:- http: paths: - backend: serviceName: hello-world-svc servicePort: 8080 path: / $ curl k8s-node-ip:32483/hello 配置TLS SSL访问创建证书12345678910111213141516171819202122232425# 生成 CA 自签证书mkdir cert &amp;&amp; cd certopenssl genrsa -out ca-key.pem 2048openssl req -x509 -new -nodes -key ca-key.pem -days 10000 -out ca.pem -subj &quot;/CN=kube-ca&quot;# 编辑 openssl 配置cp /etc/pki/tls/openssl.cnf .vim openssl.cnf# 主要修改如下[req]req_extensions = v3_req # 这行默认注释关着的 把注释删掉# 下面配置是新增的[ v3_req ]basicConstraints = CA:FALSEkeyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = dashboard.mritd.meDNS.2 = kibana.mritd.me# 生成证书openssl genrsa -out ingress-key.pem 2048openssl req -new -key ingress-key.pem -out ingress.csr -subj &quot;/CN=kube-ingress&quot; -config openssl.cnfopenssl x509 -req -in ingress.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out ingress.pem -days 365 -extensions v3_req -extfile openssl.cnf 创建 Secret创建好证书以后，需要将证书内容放到 secret 中，secret 中全部内容需要 base64 编码，然后注意去掉换行符(变成一行) 1234567891011vim ingress-secret.ymlapiVersion: v1data: tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5akNDQWQ2Z0F3SUJBZ0lKQU5TR2dNNnYvSVd5TUEwR0NTcUdTSWIzRFFFQkJRVUFNQkl4RURBT0JnTlYKQkFNTUIydDFZbVV0WTJFd0hoY05NVGN3TXpBME1USTBPRFF5V2hjTk1UZ3dNekEwTVRJME9EUXlXakFYTVJVdwpFd1lEVlFRRERBeHJkV0psTFdsdVozSmxjM013Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLCkFvSUJBUUM2dkNZRFhGSFpQOHI5Zk5jZXlkV015VVlELzAwQ2xnS0M2WjNpYWZ0QlRDK005TmcrQzloUjhJUE4KWW00cjZOMkw1MmNkcmZvQnBHZXovQVRIT0NJYUhJdlp1K1ZaTzNMZjcxZEVLR09nV21LMTliSVAzaGpSeDZhWQpIeGhEVWNab3ZzYWY1UWJHRnUydEF4L2doMTFMdXpTZWJkT0Y1dUMrWHBhTGVzWWdQUjhFS0cxS0VoRXBLMDFGCmc4MjhUU1g2TXVnVVZmWHZ1OUJRUXExVWw0Q2VMOXhQdVB5T3lMSktzbzNGOEFNUHFlaS9USWpsQVFSdmRLeFYKVUMzMnBtTHRlUFVBb2thNDRPdElmR3BIOTZybmFsMW0rMXp6YkdTemRFSEFaL2k1ZEZDNXJOaUthRmJnL2NBRwppalhlQ01xeGpzT3JLMEM4MDg4a0tjenJZK0JmQWdNQkFBR2pTakJJTUM0R0ExVWRFUVFuTUNXQ0VtUmhjMmhpCmIyRnlaQzV0Y21sMFpDNXRaWUlQYTJsaVlXNWhMbTF5YVhSa0xtMWxNQWtHQTFVZEV3UUNNQUF3Q3dZRFZSMFAKQkFRREFnWGdNQTBHQ1NxR1NJYjNEUUVCQlFVQUE0SUJBUUNFN1ByRzh6MytyaGJESC8yNGJOeW5OUUNyYVM4NwphODJUUDNxMmsxUUJ1T0doS1pwR1N3SVRhWjNUY0pKMkQ2ZlRxbWJDUzlVeDF2ckYxMWhGTWg4MU9GMkF2MU4vCm5hSU12YlY5cVhYNG16eGNROHNjakVHZ285bnlDSVpuTFM5K2NXejhrOWQ1UHVaejE1TXg4T3g3OWJWVFpkZ0sKaEhCMGJ5UGgvdG9hMkNidnBmWUR4djRBdHlrSVRhSlFzekhnWHZnNXdwSjlySzlxZHd1RHA5T3JTNk03dmNOaQpseWxDTk52T3dNQ0h3emlyc01nQ1FRcVRVamtuNllLWmVsZVY0Mk1yazREVTlVWFFjZ2dEb1FKZEM0aWNwN0sxCkRPTDJURjFVUGN0ODFpNWt4NGYwcUw1aE1sNGhtK1BZRyt2MGIrMjZjOVlud3ROd24xdmMyZVZHCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K tls.key: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBdXJ3bUExeFIyVC9LL1h6WEhzblZqTWxHQS85TkFwWUNndW1kNG1uN1FVd3ZqUFRZClBndllVZkNEeldKdUsramRpK2RuSGEzNkFhUm5zL3dFeHpnaUdoeUwyYnZsV1R0eTMrOVhSQ2hqb0ZwaXRmV3kKRDk0WTBjZW1tQjhZUTFIR2FMN0duK1VHeGhidHJRTWY0SWRkUzdzMG5tM1RoZWJndmw2V2kzckdJRDBmQkNodApTaElSS1N0TlJZUE52RTBsK2pMb0ZGWDE3N3ZRVUVLdFZKZUFuaS9jVDdqOGpzaXlTcktOeGZBREQ2bm92MHlJCjVRRUViM1NzVlZBdDlxWmk3WGoxQUtKR3VPRHJTSHhxUi9lcTUycGRadnRjODJ4a3MzUkJ3R2Y0dVhSUXVhelkKaW1oVzRQM0FCb28xM2dqS3NZN0RxeXRBdk5QUEpDbk02MlBnWHdJREFRQUJBb0lCQUJtRmIzaVVISWVocFYraAp1VkQyNnQzVUFHSzVlTS82cXBzenpLVk9NTTNLMk5EZUFkUHhFSDZhYlprYmM4MUNoVTBDc21BbkQvMDdlQVRzClU4YmFrQ2FiY2kydTlYaU5uSFNvcEhlblFYNS8rKys4aGJxUGN6cndtMzg4K0xieXJUaFJvcG5sMWxncWVBOW0KVnV2NzlDOU9oYkdGZHh4YzRxaUNDdmRETDJMbVc2bWhpcFRKQnF3bUZsNUhqeVphdGcyMVJ4WUtKZ003S1p6TAplYWU0bTJDR3R0bmNyUktodklaQWxKVmpyRWoxbmVNa3RHODFTT3QyN0FjeDRlSnozbmcwbjlYSmdMMHcwU05ZCmlwd3I5Uk5PaDkxSGFsQ3JlWVB3bDRwajIva0JIdnozMk9Qb2FOSDRQa2JaeTEzcks1bnFrMHBXdUthOEcyY00KLzY4cnQrRUNnWUVBN1NEeHRzRFFBK2JESGdUbi9iOGJZQ3VhQ2N4TDlObHIxd2tuTG56VVRzRnNkTDByUm1uZAp5bWQ4aU95ME04aUVBL0xKb3dPUGRRY240WFdWdS9XbWV5MzFVR2NIeHYvWlVSUlJuNzgvNmdjZUJSNzZJL2FzClIrNVQ1TEMyRmducVd2MzMvdG0rS0gwc0J4dEM3U2tSK3Y2UndVQk1jYnM3c0dUQlR4NVV2TkVDZ1lFQXlaaUcKbDBKY0dzWHhqd1JPQ0FLZytEMlJWQ3RBVmRHbjVMTmVwZUQ4bFNZZ3krZGxQaCt4VnRiY2JCV0E3WWJ4a1BwSAorZHg2Z0p3UWp1aGN3U25uOU9TcXRrZW04ZmhEZUZ2MkNDbXl4ZlMrc1VtMkxqVzM1NE1EK0FjcWtwc0xMTC9GCkIvK1JmcmhqZW5lRi9BaERLalowczJTNW9BR0xRVFk4aXBtM1ZpOENnWUJrZGVHUnNFd3dhdkpjNUcwNHBsODkKdGhzemJYYjhpNlJSWE5KWnNvN3JzcXgxSkxPUnlFWXJldjVhc0JXRUhyNDNRZ1BFNlR3OHMwUmxFMERWZWJRSApXYWdsWVJEOWNPVXJvWFVYUFpvaFZ0U1VETlNpcWQzQk42b1pKL2hzaTlUYXFlQUgrMDNCcjQ0WWtLY2cvSlplCmhMMVJaeUU3eWJ2MjlpaWprVkVMRVFLQmdRQ2ZQRUVqZlNFdmJLYnZKcUZVSm05clpZWkRpNTVYcXpFSXJyM1cKSEs2bVNPV2k2ZlhJYWxRem1hZW1JQjRrZ0hDUzZYNnMyQUJUVWZLcVR0UGxKK3EyUDJDd2RreGgySTNDcGpEaQpKYjIyS3luczg2SlpRY2t2cndjVmhPT1Z4YTIvL1FIdTNXblpSR0FmUGdXeEcvMmhmRDRWN1R2S0xTNEhwb1dQCm5QZDV0UUtCZ0QvNHZENmsyOGxaNDNmUWpPalhkV0ZTNzdyVFZwcXBXMlFoTDdHY0FuSXk5SDEvUWRaOXYxdVEKNFBSanJseEowdzhUYndCeEp3QUtnSzZmRDBXWmZzTlRLSG01V29kZUNPWi85WW13cmpPSkxEaUU3eFFNWFBzNQorMnpVeUFWVjlCaDI4cThSdnMweHplclQ1clRNQ1NGK0Q5NHVJUmkvL3ZUMGt4d05XdFZxCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==kind: Secretmetadata: name: ingress-secret namespace: kube-systemtype: Opaque kubectl create -f ingress-secret.yml 快速创建 Secret kubectl create secret tls ingress-secret –key cert/ingress-key.pem –cert cert/ingress.pem 重新部署123456789101112131415161718192021222324apiVersion: extensions/v1beta1kind: Ingressmetadata: name: dashboard-kibana-ingress namespace: kube-systemspec: tls: - hosts: - dashboard.mritd.me - kibana.mritd.me secretName: ingress-secret rules: - host: dashboard.mritd.me http: paths: - backend: serviceName: kubernetes-dashboard servicePort: 80 - host: kibana.mritd.me http: paths: - backend: serviceName: kibana-logging servicePort: 5601 注意:一个 Ingress 只能使用一个 secret(secretName 段只能有一个)，也就是说只能用一个证书，更直白的说就是如果你在一个 Ingress 中配置了多个域名，那么使用 TLS 的话必须保证证书支持该 Ingress 下所有域名；并且这个 secretName 一定要放在上面域名列表最后位置，否则会报错 did not find expected key无法创建；同时上面的 hosts 段下域名必须跟下面的 rules 中完全匹配 更需要注意一点：Kubernetes Ingress 默认情况下，当你不配置证书时，会默认给你一个 TLS 证书的，也就是说你 Ingress 中配置错了，比如写了2个 secretName、或者 hosts 段中缺了某个域名，那么对于写了多个 secretName 的情况，所有域名全会走默认证书；对于 hosts 缺了某个域名的情况，缺失的域名将会走默认证书，部署时一定要验证一下证书，不能 “有了就行”；更新 Ingress 证书可能需要等一段时间才会生效 参考文档Kubernetes Nginx Ingress 教程","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/tags/kubernetes/"}],"keywords":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}]},{"title":"Kubernetes-搭建本地环境","slug":"Kubernetes-搭建本地环境","date":"2018-08-07T05:27:45.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/07/Kubernetes-搭建本地环境/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/07/Kubernetes-搭建本地环境/","excerpt":"","text":"kubernetes 搭建本地环境 kubernetes 搭建本地环境 Chocolatey安装 更换镜像 安装virtualbox 添加所需要的库 更新yum缓存 安装virtualbox 安装 DKMS、更新内核 开启虚拟机虚化 安装 docker 安装kubectl 修改kubernetes.repo 安装kubectl、kubelet、kubeadm(所有节点) Minikube 下载安装 配置环境变量 启动 停止 删除 访问 Kubernetes部署 拉取镜像 发布服务 命令行模式 声明式模式(推荐) 查看Pod 查看service 查看日志 更新配置 销毁服务 客户端访问 查看master 查看config 问题 如何关闭防火墙？ minikube镜像下载不了？ 参考文献 Chocolatey安装安装 Chocolatey管理员身份运行cmd.exe 1@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot; choco choco upgrade chocolatey choco install kubernetes-cli 更换镜像[防火墙] $ cd /etc/sysconfig/network-scripts$ service network restart [更换yum] $ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo $ yum makecache $ yum repolist $ yum repoinfo 安装virtualbox添加所需要的库 $ yum install wget$ cd /etc/yum.repos.d/$ wget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repo virtualbox.repo内容如下: 1234567[virtualbox]name=Oracle Linux / RHEL / CentOS-$releasever / $basearch - VirtualBoxbaseurl=http://download.virtualbox.org/virtualbox/rpm/el/$releasever/$basearchenabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://www.virtualbox.org/download/oracle_vbox.asc 更新yum缓存 $ yum clean all $ yum makecache 安装virtualbox $ yum install VirtualBox-5.1 安装 DKMS、更新内核 $ yum -y install gcc make glibc kernel-headers kernel-devel dkms$ yum -y update kernel$ reboot 开启虚拟机虚化需要在BIOS里开启虚拟机虚化 安装 docker $ yum search docker$ yum install -y docker$ systemctl start docker 安装kubectl修改kubernetes.repo12345[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0 安装kubectl、kubelet、kubeadm(所有节点) kubelet: 运行在cluster所有节点上,负责启动POD和容器 kubeadm: 用于初始化cluster kubectl: kubectl是kubenetes命令行工具，通过kubectl可以部署和管理应用，查看各种资源，创建，删除和更新组件 $ yum install -y kubectl$ yum install -y kubelet$ yum install -y kubeadm MinikubeMinikube 是一个允许开发人员在本地使用和运行 Kubernetes 集群的工具 下载安装下载minikube[Linux] $ curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v0.28.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ [Windows] $ choco install minikube 配置环境变量MINIKUBE_HOME=D:\\kuberbnetesMINIKUBE_WANTREPORTERRORPROMPT=falseMINIKUBE_WANTUPDATENOTIFICATION=false 启动 $ minikube start –registry-mirror=https://registry.docker-cn.com–vm-driver=none //不用虚拟机 $ minikube start –vm-driver=virtualbox –registry-mirror=https://registry.docker-cn.com $ minikube start –vm-driver=hyperv –registry-mirror=https://registry.docker-cn.com Windowswindows10可以使用自带hyper-v参考启动配置: 12345$ minikube start --vm-driver=hyperv --hyperv-virtual-switch=minikube-Switch --registry-mirror=https://registry.docker-cn.com$ minikube start --vm-driver=&quot;hyperv&quot; --memory=4096 --cpus=4 --hyperv-virtual-switch=&quot;minikube-Switch&quot; --v=7 --alsologtostderr$ minikube start --vm-driver=&quot;hyperv&quot; --hyperv-virtual-switch=&quot;minikube-Switch&quot; --v=7 --alsologtostderr 作者配置(通过测试) $ minikube start –vm-driver “hyperv” –hyperv-virtual-switch “minikube-Switch” –v 9999 –alsologtostderr 停止 $ minikube stop 删除启动失败需要rm -rf 删除 ./minikube下的内容,再使用 $ minikube delete 最后重新执行启动命令 访问 $ minikube dashboard$ minikube service hello-node Kubernetes部署拉取镜像 $ docker pull chenliujin/defaultbackend:1.4$ docker tag chenliujin/defaultbackend:1.4 gcr.io/google_containers/defaultbackend:1.4 发布服务这里用NodePort对外提供服务 命令行模式 $kubectl run hello-minikube –image=k8s.gcr.io/echoserver:1.4 –port=8081$kubectl expose deployment hello-minikube –type=NodePort $ kubectl run –image=nginx nginx-app –port=80$ kubectl expose deployment nginx-app –port=80 –name=nginx-http –type=NodePort 设置镜像 $ kubectl set image deployment/hello-node hello-node=hello-node:v2 声明式模式(推荐)推荐使用 $ kubectl create -f nginx-rc.yaml 123456789101112131415161718apiVersion: v1 kind: ReplicationControllermetadata:name: nginx-rcspec:replicas: 2selector:app: nginxtemplate:metadata:labels:app: nginxspec:containers:- name: nginximage: nginxports:- containerPort: 80 $ kubectl create -f nginx-service.yaml 123456789101112apiVersion: v1 kind: Servicemetadata:name: nginx-servicespec:ClusterIP: Noneports:- port: 80targetPort: 80protocol: TCPselector:app: nginx 查看Pod查看默认的pod $ kubectl get pods 查看所有namespace的pod数据 $ kubectl get pods –all-namespaces -o wide 请求部署的service $ curl $(minikube service hello-minikube –url) 查看service $ kubectl get services$ kubectl get service –all-namespaces 查看日志$ minikube logs 更新配置 $ kubectl replace -f rc-nginx.yaml 销毁服务 $ kubectl delete service nginx-service$ kubectl delete deployment nginx-pod$ kubectl delete rc nginx-service 客户端访问 $ curl ‘192.168.64.2:30716’$ minikube service nginx-http访问部署service$ minikube service hello-node 查看master $ kubectl cluster-info 查看config $ kubectl config view 问题如何关闭防火墙？关闭防火墙 $ systemctl stop firewalld //临时关闭$ systemctl disable firewalld //禁止开机启动$ Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.$ Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 访问: http://127.0.0.1:8001/ui minikube镜像下载不了？下载不了如何解决说明：由于GFW的原因下载不下来的，都可以到时速云去下载相应的镜像（只要把grc.io换成index.tenxcloud.com就可以了。或者用私用镜像仓库，tag之后上传到之后看到的镜像是自己私有镜像仓库的。 1$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 &amp;&amp; sudo docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause-amd64:3.1 k8s.gcr.io/pause-amd64:3.1 &amp;&amp; sudo /usr/bin/kubeadm init --config /var/lib/kubeadm.yaml --ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests --ignore-preflight-errors=DirAvailable--data-minikube --ignore-preflight-errors=Port-10250 --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-etcd.yaml --ignore-preflight-errors=Swap --ignore-preflight-errors=CRI 123$ minikube ssh$ docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0$ docker tag registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0 gcr.io/google_containers/pause-amd64:3.0 参考文献[参考] Kubernetes本地实验环境通过Minikube快速搭建一个本地的Kubernetes单节点环境","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/tags/kubernetes/"}],"keywords":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}]},{"title":"Kubernetes-介绍","slug":"Kubernetes-介绍","date":"2018-08-07T03:09:04.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/08/07/Kubernetes-介绍/","link":"","permalink":"https://chaoscoffee.github.io/2018/08/07/Kubernetes-介绍/","excerpt":"","text":"Kubernetes 介绍 Kubernetes 介绍 Kubernetes架构 架构图 节点 分层架构 使用Kubernetes能做什么？ Kubernetes不是什么？ Kubernetes架构架构图Kubernetes集群包含有节点代理kubelet和Master组件(APIs, scheduler, etc)，一切都基于分布式的存储系统。下面这张图是Kubernetes的架构图。 节点在这张系统架构图中，我们把服务分为运行在工作节点上的服务和组成集群级别控制板的服务。 Kubernetes节点有运行应用容器必备的服务，而这些都是受Master的控制。 每次个节点上当然都要运行Docker。Docker来负责所有具体的映像下载和容器运行。 Kubernetes主要由以下几个核心组件组成： etcd保存了整个集群的状态； apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制； controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等； scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上； kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理； Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）； kube-proxy负责为Service提供cluster内部的服务发现和负载均衡； 除了核心组件，还有一些推荐的Add-ons： kube-dns负责为整个集群提供DNS服务 Ingress Controller为服务提供外网入口 Heapster提供资源监控 Dashboard提供GUI Federation提供跨可用区的集群 Fluentd-elasticsearch提供集群日志采集、存储与查询 分层架构Kubernetes设计理念和功能其实就是一个类似Linux的分层架构，如下图所示 核心层：Kubernetes最核心的功能，对外提供API构建高层的应用，对内提供插件式应用执行环境 应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等） 管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态Provision等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy等） 接口层：kubectl命令行工具、客户端SDK以及集群联邦 生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴 Kubernetes外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS应用、ChatOps等 Kubernetes内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 使用Kubernetes能做什么？可以在物理或虚拟机的Kubernetes集群上运行容器化应用，Kubernetes能提供一个以“容器为中心的基础架构”，满足在生产环境中运行应用的一些常见需求，如： 多个进程（作为容器运行）协同工作。（Pod） 存储系统挂载 Distributing secrets 应用健康检测 应用实例的复制 Pod自动伸缩/扩展 Naming and discovering 负载均衡 滚动更新 资源监控 日志访问 调试应用程序 提供认证和授权 Kubernetes不是什么？Kubernetes并不是传统的PaaS（平台即服务）系统。 Kubernetes不限制支持应用的类型，不限制应用框架。限制受支持的语言runtimes (例如, Java, Python, Ruby)，满足12-factor applications 。不区分 “apps” 或者“services”。 Kubernetes支持不同负载应用，包括有状态、无状态、数据处理类型的应用。只要这个应用可以在容器里运行，那么就能很好的运行在Kubernetes上。 Kubernetes不提供中间件（如message buses）、数据处理框架（如Spark）、数据库(如Mysql)或者集群存储系统(如Ceph)作为内置服务。但这些应用都可以运行在Kubernetes上面。 Kubernetes不部署源码不编译应用。持续集成的 (CI)工作流方面，不同的用户有不同的需求和偏好的区域，因此，我们提供分层的 CI工作流，但并不定义它应该如何工作。 Kubernetes允许用户选择自己的日志、监控和报警系统。 Kubernetes不提供或授权一个全面的应用程序配置 语言/系统（例如，jsonnet）。 Kubernetes不提供任何机器配置、维护、管理或者自修复系统。 另一方面，大量的Paas系统都可以运行在Kubernetes上，比如Openshift、Deis、Gondor。可以构建自己的Paas平台，与自己选择的CI系统集成。 由于Kubernetes运行在应用级别而不是硬件级，因此提供了普通的Paas平台提供的一些通用功能，比如部署，扩展，负载均衡，日志，监控等。这些默认功能是可选的。 另外，Kubernetes不仅仅是一个“编排系统”；它消除了编排的需要。“编排”的定义是指执行一个预定的工作流：先执行A，之B，然C。相反，Kubernetes由一组独立的可组合控制进程组成。怎么样从A到C并不重要，达到目的就好。当然集中控制也是必不可少，方法更像排舞的过程。这使得系统更加易用、强大、弹性和可扩展。","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/tags/kubernetes/"}],"keywords":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://chaoscoffee.github.io/categories/kubernetes/"}]},{"title":"Markdown语法","slug":"Markdown语法","date":"2018-07-27T03:34:20.000Z","updated":"2018-08-21T02:11:05.940Z","comments":false,"path":"2018/07/27/Markdown语法/","link":"","permalink":"https://chaoscoffee.github.io/2018/07/27/Markdown语法/","excerpt":"","text":"欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。 块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入","categories":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://chaoscoffee.github.io/tags/markdown/"}],"keywords":[{"name":"tools","slug":"tools","permalink":"https://chaoscoffee.github.io/categories/tools/"}]}]}